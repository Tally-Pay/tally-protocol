//! Dashboard-specific data types and structures

#![forbid(unsafe_code)]
#![allow(clippy::arithmetic_side_effects)] // Safe for business logic calculations
#![allow(clippy::cast_possible_truncation)] // Controlled truncation for display formatting
#![allow(clippy::cast_lossless)] // Safe casting for USDC formatting

use crate::program_types::{PaymentTerms, PaymentAgreement};
use anchor_client::solana_sdk::pubkey::Pubkey;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Overview statistics for a payee dashboard
#[allow(clippy::derive_partial_eq_without_eq)] // Contains f64 methods
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Overview {
    /// Total revenue earned (in USDC microlamports)
    pub total_revenue: u64,
    /// Number of active payment agreements
    pub active_agreements: u32,
    /// Number of inactive payment agreements
    pub inactive_agreements: u32,
    /// Total number of payment terms
    pub total_payment_terms: u32,
    /// Revenue this month (in USDC microlamports)
    pub monthly_revenue: u64,
    /// New payment agreements this month
    pub monthly_new_agreements: u32,
    /// Paused payment agreements this month
    pub monthly_paused_agreements: u32,
    /// Average revenue per payer (in USDC microlamports)
    pub average_revenue_per_payer: u64,
    /// Payee authority address
    pub payee_authority: Pubkey,
    /// USDC mint being used
    pub usdc_mint: Pubkey,
}

impl Overview {
    /// Get total revenue formatted as USDC (6 decimal places)
    #[must_use]
    #[allow(clippy::cast_precision_loss)]
    pub fn total_revenue_formatted(&self) -> f64 {
        self.total_revenue as f64 / 1_000_000.0
    }

    /// Get monthly revenue formatted as USDC (6 decimal places)
    #[must_use]
    #[allow(clippy::cast_precision_loss)]
    pub fn monthly_revenue_formatted(&self) -> f64 {
        self.monthly_revenue as f64 / 1_000_000.0
    }

    /// Get average revenue per payer formatted as USDC (6 decimal places)
    #[must_use]
    #[allow(clippy::cast_precision_loss)]
    pub fn average_revenue_per_payer_formatted(&self) -> f64 {
        self.average_revenue_per_payer as f64 / 1_000_000.0
    }

    /// Calculate churn rate as a percentage
    #[must_use]
    #[allow(clippy::cast_precision_loss)]
    pub fn churn_rate(&self) -> f64 {
        let total_agreements = self.active_agreements + self.inactive_agreements;
        if total_agreements == 0 {
            return 0.0;
        }
        (self.inactive_agreements as f64 / total_agreements as f64) * 100.0
    }
}

/// Analytics data for specific payment terms
#[allow(clippy::derive_partial_eq_without_eq)] // Contains f64 fields
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PaymentTermsAnalytics {
    /// The payment terms being analyzed
    pub payment_terms: PaymentTerms,
    /// Payment terms PDA address
    pub payment_terms_address: Pubkey,
    /// Number of active payment agreements
    pub active_count: u32,
    /// Number of inactive payment agreements
    pub inactive_count: u32,
    /// Total revenue generated by these payment terms (in USDC microlamports)
    pub total_revenue: u64,
    /// Revenue this month (in USDC microlamports)
    pub monthly_revenue: u64,
    /// New payment agreements this month
    pub monthly_new_agreements: u32,
    /// Paused payment agreements this month
    pub monthly_paused_agreements: u32,
    /// Average payment agreement duration in days
    pub average_duration_days: f64,
    /// Conversion rate percentage (if applicable)
    pub conversion_rate: Option<f64>,
}

impl PaymentTermsAnalytics {
    /// Get total revenue formatted as USDC (6 decimal places)
    #[must_use]
    #[allow(clippy::cast_precision_loss)]
    pub fn total_revenue_formatted(&self) -> f64 {
        self.total_revenue as f64 / 1_000_000.0
    }

    /// Get monthly revenue formatted as USDC (6 decimal places)
    #[must_use]
    #[allow(clippy::cast_precision_loss)]
    pub fn monthly_revenue_formatted(&self) -> f64 {
        self.monthly_revenue as f64 / 1_000_000.0
    }

    /// Calculate total payment agreements (active + inactive)
    #[must_use]
    pub const fn total_agreements(&self) -> u32 {
        self.active_count + self.inactive_count
    }

    /// Calculate churn rate as a percentage
    #[must_use]
    #[allow(clippy::cast_precision_loss)]
    pub fn churn_rate(&self) -> f64 {
        let total = self.total_agreements();
        if total == 0 {
            return 0.0;
        }
        (self.inactive_count as f64 / total as f64) * 100.0
    }

    /// Calculate monthly growth rate as a percentage
    #[must_use]
    #[allow(clippy::cast_precision_loss)]
    pub fn monthly_growth_rate(&self) -> f64 {
        if self.monthly_paused_agreements >= self.monthly_new_agreements {
            return 0.0;
        }
        let net_growth = self.monthly_new_agreements - self.monthly_paused_agreements;
        let base = if self.active_count >= net_growth {
            self.active_count - net_growth
        } else {
            return 100.0; // If we can't calculate a base, assume 100% growth
        };

        if base == 0 {
            return 100.0;
        }

        (net_growth as f64 / base as f64) * 100.0
    }
}

/// Real-time event data for dashboard monitoring
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct DashboardEvent {
    /// Event type
    pub event_type: DashboardEventType,
    /// Payment terms address (if applicable)
    pub payment_terms_address: Option<Pubkey>,
    /// Payment agreement address (if applicable)
    pub agreement_address: Option<Pubkey>,
    /// Payer address (if applicable)
    pub payer: Option<Pubkey>,
    /// Amount involved (if applicable, in USDC microlamports)
    pub amount: Option<u64>,
    /// Transaction signature
    pub transaction_signature: Option<String>,
    /// Unix timestamp when the event occurred
    pub timestamp: i64,
    /// Additional event metadata
    pub metadata: HashMap<String, String>,
}

/// Types of events that can occur in the payment agreement system
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum DashboardEventType {
    /// New payment agreement started
    AgreementStarted,
    /// Payment executed on an agreement
    PaymentExecuted,
    /// Payment agreement paused
    AgreementPaused,
    /// Payment failed
    PaymentFailed,
    /// New payment terms created
    PaymentTermsCreated,
    /// Payment terms updated
    PaymentTermsUpdated,
    /// Payee fees withdrawn
    FeesWithdrawn,
}

impl DashboardEvent {
    /// Get amount formatted as USDC (6 decimal places)
    #[must_use]
    #[allow(clippy::cast_precision_loss)]
    pub fn amount_formatted(&self) -> Option<f64> {
        self.amount.map(|amount| amount as f64 / 1_000_000.0)
    }

    /// Check if this event affects revenue calculations
    #[must_use]
    pub const fn affects_revenue(&self) -> bool {
        matches!(
            self.event_type,
            DashboardEventType::AgreementStarted | DashboardEventType::PaymentExecuted
        )
    }

    /// Check if this event affects payment agreement counts
    #[must_use]
    pub const fn affects_agreement_count(&self) -> bool {
        matches!(
            self.event_type,
            DashboardEventType::AgreementStarted | DashboardEventType::AgreementPaused
        )
    }
}

/// Event stream for real-time dashboard updates
#[derive(Clone, Debug)]
pub struct EventStream {
    /// Buffer of recent events
    pub events: Vec<DashboardEvent>,
    /// Maximum number of events to buffer
    pub max_buffer_size: usize,
    /// Whether the stream is actively monitoring
    pub is_active: bool,
}

impl EventStream {
    /// Create a new event stream with default buffer size
    #[must_use]
    pub fn new() -> Self {
        Self::with_buffer_size(1000)
    }

    /// Create a new event stream with custom buffer size
    #[must_use]
    pub fn with_buffer_size(buffer_size: usize) -> Self {
        Self {
            events: Vec::with_capacity(buffer_size),
            max_buffer_size: buffer_size,
            is_active: false,
        }
    }

    /// Add an event to the stream
    pub fn add_event(&mut self, event: DashboardEvent) {
        self.events.push(event);

        // Remove oldest events if buffer is full
        if self.events.len() > self.max_buffer_size {
            self.events.remove(0);
        }
    }

    /// Get recent events within a time window (in seconds)
    #[must_use]
    pub fn recent_events(&self, window_secs: i64) -> Vec<&DashboardEvent> {
        let now = chrono::Utc::now().timestamp();
        let cutoff = now - window_secs;

        self.events
            .iter()
            .filter(|event| event.timestamp >= cutoff)
            .collect()
    }

    /// Get events of a specific type
    #[must_use]
    pub fn events_of_type(&self, event_type: &DashboardEventType) -> Vec<&DashboardEvent> {
        self.events
            .iter()
            .filter(|event| &event.event_type == event_type)
            .collect()
    }

    /// Clear all events from the buffer
    pub fn clear(&mut self) {
        self.events.clear();
    }

    /// Start monitoring events
    pub const fn start(&mut self) {
        self.is_active = true;
    }

    /// Stop monitoring events
    pub const fn stop(&mut self) {
        self.is_active = false;
    }
}

impl Default for EventStream {
    fn default() -> Self {
        Self::new()
    }
}

/// Payment agreement details with enhanced information for dashboard display
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct DashboardAgreement {
    /// The payment agreement data from the blockchain
    pub payment_agreement: PaymentAgreement,
    /// Payment agreement PDA address
    pub address: Pubkey,
    /// Associated payment terms information
    pub payment_terms: PaymentTerms,
    /// Payment terms PDA address
    pub payment_terms_address: Pubkey,
    /// Human-readable status
    pub status: AgreementStatus,
    /// Days until next renewal (if active)
    pub days_until_renewal: Option<i64>,
    /// Total amount paid over agreement lifetime
    pub total_paid: u64,
}

/// Human-readable payment agreement status
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum AgreementStatus {
    /// Payment agreement is active and current
    Active,
    /// Payment agreement is active but overdue (within grace period)
    Overdue,
    /// Payment agreement is inactive/paused
    Inactive,
    /// Payment agreement is expired (past grace period)
    Expired,
}

impl DashboardAgreement {
    /// Get total paid amount formatted as USDC (6 decimal places)
    #[must_use]
    #[allow(clippy::cast_precision_loss)]
    pub fn total_paid_formatted(&self) -> f64 {
        self.total_paid as f64 / 1_000_000.0
    }

    /// Calculate the status based on payment agreement data
    #[must_use]
    pub const fn calculate_status(
        payment_agreement: &PaymentAgreement,
        current_timestamp: i64,
    ) -> AgreementStatus {
        if !payment_agreement.active {
            return AgreementStatus::Inactive;
        }

        if current_timestamp <= payment_agreement.next_payment_ts {
            AgreementStatus::Active
        } else {
            // We would need the payment terms' grace period to determine if it's overdue or expired
            // For now, just mark as overdue if past renewal time
            AgreementStatus::Overdue
        }
    }

    /// Calculate days until next renewal
    #[must_use]
    pub const fn calculate_days_until_renewal(
        next_payment_ts: i64,
        current_timestamp: i64,
    ) -> Option<i64> {
        if next_payment_ts <= current_timestamp {
            return None; // Past due
        }

        let seconds_diff = next_payment_ts - current_timestamp;
        Some(seconds_diff / 86400) // Convert to days
    }
}
